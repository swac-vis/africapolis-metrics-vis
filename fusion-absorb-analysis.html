<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fusion & Absorb – Country Analysis</title>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/modules/sankey.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        /* Palette from index.html map/chart: primary #5B8FA3 (M), highlight #D4A574 (L), S #6B9B8A, Total #8B9A9F; light fills #E8F0F5, #F5E8D4 */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        * {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        *::-webkit-scrollbar {
            display: none;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #FAF9F6;
            color: #2C3E50;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 1280px;
        }
        .header {
            flex-shrink: 0;
            background: #fff;
            padding: 8px 14px;
            border-bottom: 1px solid #E8E6E1;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .header h1 { font-size: 17px; font-weight: 600; color: #2C3E50; }
        .header a {
            color: #5B8FA3;
            text-decoration: none;
            font-size: 12px;
        }
        .header a:hover { text-decoration: underline; }
        .main {
            flex: 1;
            display: flex;
            gap: 8px;
            padding: 8px;
            min-height: 0;
        }
        .panel-left {
            width: 380px;
            min-width: 320px;
            display: flex;
            flex-direction: column;
            gap: 0;
            background: #fff;
            border-radius: 8px;
            border: 1px solid #E8E6E1;
            min-height: 0;
            overflow: hidden;
        }
        .panel-center {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0;
            min-width: 0;
            flex-basis: 840px;
            min-height: 0;
        }
        .country-overview-panel {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .country-overview-panel.hidden { display: none !important; }
        .agg-entry-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-shrink: 0;
            padding: 10px 14px;
            background: #E8F0F5;
            border: 1px solid #5B8FA3;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        .agg-entry-bar .agg-entry-text { font-size: 12px; color: #2C3E50; }
        .agg-entry-bar .agg-entry-text strong { color: #5B8FA3; }
        .btn-view-agg {
            padding: 6px 12px;
            font-size: 12px;
            border: 1px solid #5B8FA3;
            background: #5B8FA3;
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
        }
        .btn-view-agg:hover { background: #4a7a8c; border-color: #4a7a8c; color: #fff; }
        .agg-view-panel {
            flex: 1;
            min-height: 0;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        .agg-view-panel.visible { display: flex !important; }
        .agg-view-panel .agg-section { flex: 1; min-height: 0; display: flex; flex-direction: column; overflow: hidden; }
        .agg-view-panel .agg-toolbar { flex-shrink: 0; padding: 10px 14px; background: #fff; border-bottom: 1px solid #E8E6E1; }
        .panel-section {
            padding: 12px 14px;
            border-bottom: 1px solid #F0EEEA;
        }
        .panel-section:last-child {
            border-bottom: none;
        }
        .panel-section-filters {
            flex-shrink: 0;
            background: #FAFBFC;
        }
        .panel-section-list {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            padding: 0 6px;
        }
        .panel-title {
            font-size: 11px;
            font-weight: 600;
            color: #6B7A8A;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            margin-bottom: 10px;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .filter-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .filter-row label {
            flex: 0 0 72px;
            font-size: 12px;
            color: #2C3E50;
        }
        .filter-row select,
        .filter-row input[type="text"] {
            flex: 1;
            min-width: 0;
        }
        .filter-row-button {
            margin-top: 4px;
            display: flex;
            gap: 8px;
        }
        .filter-row-button button {
            flex: 1;
            min-width: 0;
        }
        select, input[type="text"] {
            padding: 8px 10px;
            border: 1px solid #D4D1CA;
            border-radius: 6px;
            font-size: 12px;
            background: #fff;
            color: #2C3E50;
        }
        select:focus, input:focus {
            outline: none;
            border-color: #5B8FA3;
            box-shadow: 0 0 0 2px rgba(91, 143, 163, 0.1);
        }
        button {
            padding: 8px 12px;
            border: 1px solid #D4D1CA;
            border-radius: 6px;
            font-size: 12px;
            background: #fff;
            color: #2C3E50;
            cursor: pointer;
        }
        button:hover { background: #F5F3F0; border-color: #5B8FA3; color: #5B8FA3; }
        .score-desc {
            font-size: 11px;
            color: #6B7A8A;
            line-height: 1.45;
            margin-top: 6px;
            padding: 8px 10px;
            background: #fff;
            border-radius: 6px;
            border: 1px solid #E8E6E1;
        }
        .column-toggles {
            display: flex;
            flex-wrap: wrap;
            gap: 10px 14px;
            align-items: center;
        }
        .column-toggle {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: #2C3E50;
            cursor: pointer;
        }
        .column-toggle input { cursor: pointer; }
        .collapse-section {
            border-bottom: 1px solid #F0EEEA;
        }
        .collapse-section:last-of-type {
            border-bottom: none;
        }
        .collapse-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            font-size: 11px;
            font-weight: 600;
            color: #6B7A8A;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            cursor: pointer;
            user-select: none;
            background: #FAFBFC;
        }
        .collapse-header:hover {
            color: #5B8FA3;
            background: #F5F7F8;
        }
        .collapse-header .collapse-icon {
            font-size: 10px;
            color: #6B7A8A;
            transition: transform 0.15s ease;
        }
        .collapse-section.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }
        .collapse-body {
            padding: 8px 14px 12px;
        }
        .collapse-section.collapsed .collapse-body {
            display: none;
        }
        .list-header {
            padding: 8px 8px;
            font-size: 11px;
            font-weight: 600;
            color: #6B7A8A;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            background: #FAFBFC;
            border-bottom: 1px solid #E8E6E1;
        }
        .chart-card {
            background: #fff;
            border-radius: 6px;
            border: 1px solid #E8E6E1;
            padding: 8px;
            flex: 1;
            min-height: 180px;
            display: flex;
            flex-direction: column;
        }
        .chart-card h3 {
            font-size: 11px;
            font-weight: 600;
            color: #2C3E50;
            margin-bottom: 6px;
        }
        .chart-container {
            flex: 1;
            min-height: 160px;
            position: relative;
        }
        .charts-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
            min-height: 0;
        }
        .charts-bar-row {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            flex-shrink: 0;
            min-height: 300px;
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 6px;
            -webkit-overflow-scrolling: touch;
        }
        .charts-bar-row .chart-card {
            flex: 0 0 auto;
            min-height: 280px;
            min-width: 300px;
            width: 300px;
        }
        .charts-bar-row .chart-container {
            min-height: 240px;
        }
        .chart-card-bubble {
            flex: 1;
            min-height: 220px;
        }
        .chart-card-bubble .chart-container {
            min-height: 180px;
        }
        .chart-container-bubble {
            position: relative;
        }
        .bubble-tooltip {
            position: absolute;
            z-index: 100;
            pointer-events: none;
            display: none;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.96);
            border: 1px solid #E8E6E1;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-size: 12px;
            color: #2C3E50;
            line-height: 1.4;
            max-width: 280px;
        }
        .bubble-tooltip.visible {
            display: block;
        }
        .bubble-tooltip .tt-title { font-weight: 600; margin-bottom: 4px; }
        .bubble-tooltip .tt-body { white-space: pre-line; }
        .selection-rect {
            position: absolute;
            border: 2px dashed #6B9B8A;
            background: rgba(107, 155, 138, 0.12);
            pointer-events: none;
            display: none;
            z-index: 2;
        }
        .selection-rect.visible {
            display: block;
        }
        .chart-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }
        .chart-card-header h3 {
            margin-bottom: 0;
        }
        .chart-toolbar {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .chart-toolbar-btn {
            width: 32px;
            height: 32px;
            padding: 0;
            border: 1px solid #D4D1CA;
            border-radius: 4px;
            background: #fff;
            color: #2C3E50;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .chart-toolbar-btn:hover {
            background: #F5F3F0;
            border-color: #5B8FA3;
            color: #5B8FA3;
        }
        .chart-toolbar-btn.active {
            background: #E8F0F5;
            border-color: #5B8FA3;
            color: #5B8FA3;
        }
        .chart-toolbar-icon {
            width: 18px;
            height: 18px;
        }
        .table-wrap {
            flex: 1;
            min-height: 0;
            overflow: auto;
        }
        .data-table {
            width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
            font-size: 12px;
        }
        .data-table th, .data-table td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid #F0EEEA;
        }
        .data-table thead {
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .data-table th {
            background: #F5F3F0;
            color: #6B7A8A;
            font-weight: 600;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
            padding: 4px 6px;
        }
        .data-table th:hover { background: #E8E6E1; }
        .data-table th.sorted-asc::after { content: ' ▲'; font-size: 9px; }
        .data-table th.sorted-desc::after { content: ' ▼'; font-size: 9px; }
        .data-table tbody tr {
            cursor: pointer;
        }
        .data-table tbody tr:hover { background: #F8F7F5; }
        .data-table tbody tr.highlighted {
            background: #F5E8D4 !important;
            border-left: 4px solid #D4A574;
            box-shadow: inset 0 0 0 1px rgba(212, 165, 116, 0.35);
        }
        .data-table .num { text-align: right; }
        .data-table td:first-child, .data-table th:first-child { font-weight: 500; color: #2C3E50; width: 28%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .score-bar {
            height: 6px;
            background: #E8E6E1;
            border-radius: 3px;
            overflow: hidden;
        }
        .score-bar-fill {
            height: 100%;
            background: #5B8FA3;
            border-radius: 3px;
        }
        .loading { padding: 20px; text-align: center; color: #6B7A8A; }
        .empty-state { padding: 20px; text-align: center; color: #6B7A8A; font-size: 12px; }
        /* Agglomeration analysis view (replaces center when a country is selected) */
        .agg-view-panel .agg-toolbar { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 14px; background: #fff; border: 1px solid #E8E6E1; border-radius: 8px 8px 0 0; flex-shrink: 0; }
        .agg-view-panel .agg-toolbar h2 { font-size: 14px; font-weight: 600; color: #2C3E50; margin: 0; }
        .agg-view-panel .btn-back { padding: 6px 12px; font-size: 12px; border: 1px solid #5B8FA3; background: #fff; color: #5B8FA3; border-radius: 6px; cursor: pointer; }
        .agg-view-panel .btn-back:hover { background: #5B8FA3; color: #fff; }
        .agg-view-panel .agg-body { flex: 1; min-height: 0; display: flex; gap: 14px; padding: 14px; background: #FAF9F6; overflow: hidden; }
        .agg-section .agg-header { font-size: 13px; font-weight: 600; color: #2C3E50; flex-shrink: 0; }
        .agg-section .agg-placeholder { padding: 24px; text-align: center; color: #6B7A8A; font-size: 12px; background: #fff; border: 1px solid #E8E6E1; border-radius: 8px; }
        .agg-section .agg-content { flex: 1; min-height: 0; display: flex; gap: 14px; overflow: hidden; }
        .agg-section .agg-left { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 10px; overflow: hidden; }
        .agg-section .agg-sankey-box { flex: 1.5; min-height: 0; padding: 14px; border-radius: 8px; border: 1px solid #E8E6E1; background: #fff; overflow: hidden; display: flex; flex-direction: column; }
        .agg-section #aggSankeyContainer { width: 100%; flex: 1; min-height: 200px; }
        .agg-section .agg-matrix-section { flex: 1; min-height: 0; overflow: hidden; display: flex; flex-direction: column; background: #fff; padding: 14px; border-radius: 8px; border: 1px solid #E8E6E1; }
        .agg-section .agg-matrix-section h3 { font-size: 12px; font-weight: 600; margin-bottom: 8px; flex-shrink: 0; }
        .agg-section .agg-matrix-inner { flex: 1; min-height: 0; overflow: auto; }
        .agg-section .agg-list-right { flex: 0 0 38%; min-width: 260px; background: #fff; padding: 14px; border-radius: 8px; border: 1px solid #E8E6E1; display: flex; flex-direction: column; min-height: 0; overflow: hidden; }
        .agg-section .transition-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .agg-section .transition-table th, .agg-section .transition-table td { padding: 8px 12px; border: 1px solid #E8E6E1; text-align: center; }
        .agg-section .transition-table th { background: #F5F3F0; color: #6B7A8A; font-weight: 600; }
        .agg-section .transition-table th.row-header, .agg-section .transition-table td.row-header { text-align: left; }
        .agg-section .transition-table .num { text-align: right; }
        .agg-section .transition-table tr.row-total td { border-top: 2px solid #E8E6E1; }
        .agg-section .transition-table td.cell-heat { min-width: 64px; cursor: pointer; }
        .agg-section .transition-table td.cell-heat.selected { outline: 2px solid #5B8FA3; outline-offset: -1px; }
        .agg-section .transition-table th.col-header-click, .agg-section .transition-table td.row-header-click { cursor: pointer; }
        .agg-section .transition-table th.col-header-click.header-selected, .agg-section .transition-table td.row-header-click.header-selected { background: rgba(91, 143, 163, 0.25); font-weight: 600; }
        .agg-section .list-header-row { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
        .agg-section .detail-panel h3 { font-size: 12px; font-weight: 600; color: #2C3E50; margin: 0; }
        .agg-section .btn-all { padding: 4px 10px; font-size: 11px; border: 1px solid #5B8FA3; background: #fff; color: #5B8FA3; border-radius: 6px; cursor: pointer; }
        .agg-section .btn-all:hover { background: #5B8FA3; color: #fff; }
        .agg-section .detail-panel .list-scroll { flex: 1; min-height: 0; overflow: auto; }
        .agg-section .detail-panel .agg-table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .agg-section .detail-panel .agg-table th, .agg-section .detail-panel .agg-table td { padding: 6px 8px; border: 1px solid #E8E6E1; text-align: left; }
        .agg-section .detail-panel .agg-table th { background: #F5F3F0; cursor: pointer; }
        .agg-section .detail-panel .agg-table td.num { text-align: right; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Fusion & Absorb – Country Analysis</h1>
        <div style="display: flex; align-items: center; gap: 8px;">
            <a href="index.html">← Back to Urban Metrics</a>
        </div>
    </div>
    <div class="main">
        <div class="panel-left">
            <div class="collapse-section" id="collapseFilters">
                <div class="collapse-header" aria-expanded="true">
                    <span>Filters</span>
                    <span class="collapse-icon" aria-hidden="true">▼</span>
                </div>
                <div class="collapse-body">
                    <div class="filter-group">
                        <div class="filter-row">
                            <label>Metric</label>
                            <select id="metricType">
                                <option value="fusion">Fusion</option>
                                <option value="absorb">Absorb</option>
                            </select>
                        </div>
                        <div class="filter-row">
                            <label>Search</label>
                            <input type="text" id="searchCountry" placeholder="Country name...">
                        </div>
                        <div class="filter-row">
                            <label>Sort by</label>
                            <select id="sortBy">
                                <option value="score">Composite score</option>
                                <option value="sharePop">Pop %</option>
                                <option value="shareArea">Area %</option>
                                <option value="count">Count (agglos)</option>
                                <option value="population">Population</option>
                                <option value="area">Area (km²)</option>
                            </select>
                        </div>
                        <div class="filter-row">
                            <label>Top N</label>
                            <select id="topN">
                                <option value="999" selected>All</option>
                                <option value="10">10</option>
                                <option value="15">15</option>
                                <option value="20">20</option>
                                <option value="30">30</option>
                                <option value="42">42</option>
                            </select>
                        </div>
                        <div class="filter-row filter-row-button">
                            <button type="button" id="selectAll">Select all</button>
                            <button type="button" id="clearSelection">Clear selection</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="collapse-section collapsed" id="collapseListCols">
                <div class="collapse-header" aria-expanded="false">
                    <span>List columns</span>
                    <span class="collapse-icon" aria-hidden="true">▼</span>
                </div>
                <div class="collapse-body">
                    <div class="column-toggles" aria-label="Choose which columns to show in the country list">
                        <label class="column-toggle"><input type="checkbox" id="colCount"> Count</label>
                        <label class="column-toggle"><input type="checkbox" id="colArea"> Area</label>
                        <label class="column-toggle"><input type="checkbox" id="colPop"> Pop</label>
                    </div>
                    <p class="score-desc" style="margin-top: 8px;">Ctry, Pop %, Area %, Score always shown. Tick to add Count / Pop / Area.</p>
                </div>
            </div>
            <div class="collapse-section collapsed" id="collapseScore">
                <div class="collapse-header" aria-expanded="false">
                    <span>About the index</span>
                    <span class="collapse-icon" aria-hidden="true">▼</span>
                </div>
                <div class="collapse-body">
                    <p class="score-desc">Composite index (0–1): equal-weight average of normalized ranks on # agglomerations fused, population involved, and area involved. Higher = higher rank on all three indicators.</p>
                    <p class="score-desc" style="margin-top: 6px;">Pop %: fusion/absorb population as % of country total population. Area %: fusion/absorb area as % of country total area. Higher = fusion/absorb matters more for that country.</p>
                </div>
            </div>
            <div class="panel-section panel-section-list">
                <div class="list-header">Country list (click to highlight)</div>
                <div class="table-wrap">
                    <table class="data-table" id="dataTable">
                        <thead><tr id="tableHead"></tr></thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
        <div class="panel-center">
            <div class="country-overview-panel" id="countryChartsPanel">
                <div class="agg-entry-bar" id="aggEntryBar" style="display: none;">
                    <span class="agg-entry-text"><span id="aggEntryCountryName"></span> selected.</span>
                    <button type="button" class="btn-view-agg" id="btnViewAgglomeration" title="Open fusion agglomeration size transition view">View fusion agglomeration →</button>
                </div>
                <div class="charts-row">
                    <div class="charts-bar-row">
                    <div class="chart-card">
                        <h3>Composite score</h3>
                        <div class="chart-container"><canvas id="chartRank"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <h3>Count (agglos)</h3>
                        <div class="chart-container"><canvas id="chartCount"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <h3>Population</h3>
                        <div class="chart-container"><canvas id="chartPopulation"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <h3>Area (km²)</h3>
                        <div class="chart-container"><canvas id="chartArea"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <h3>Pop %</h3>
                        <div class="chart-container"><canvas id="chartSharePop"></canvas></div>
                    </div>
                    <div class="chart-card">
                        <h3>Area %</h3>
                        <div class="chart-container"><canvas id="chartShareArea"></canvas></div>
                    </div>
                </div>
                <div class="chart-card chart-card-bubble">
                    <div class="chart-card-header">
                        <h3 id="bubbleChartTitle">Score vs Count (pie = area%, size = area, color = pop%)</h3>
                        <div class="chart-toolbar" id="bubbleChartToolbar">
                            <button type="button" class="chart-toolbar-btn" id="bubbleZoomBtn" title="Zoom (drag to select area)"><svg class="chart-toolbar-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/><path d="M11 8v6"/><path d="M8 11h6"/></svg></button>
                            <button type="button" class="chart-toolbar-btn active" id="bubblePanBtn" title="Pan (drag to move)"><svg class="chart-toolbar-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 9l-3 3 3 3"/><path d="M9 5l3-3 3 3"/><path d="M15 19l-3 3-3-3"/><path d="M19 9l3 3-3 3"/><path d="M2 12h20"/><path d="M12 2v20"/></svg></button>
                            <button type="button" class="chart-toolbar-btn" id="bubbleBoxSelectBtn" title="Box select (drag to select countries, highlight in list and charts)"><svg class="chart-toolbar-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-dasharray="3 2"><rect x="3" y="3" width="18" height="18" rx="1"/></svg></button>
                            <button type="button" class="chart-toolbar-btn" id="bubbleHomeBtn" title="Reset zoom"><svg class="chart-toolbar-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg></button>
                        </div>
                    </div>
                    <div class="chart-container chart-container-bubble" id="bubbleChartContainer">
                        <div class="selection-rect" id="bubbleSelectionRect"></div>
                        <canvas id="chartScatter"></canvas>
                        <div id="bubbleTooltip" class="bubble-tooltip" aria-hidden="true"></div>
                    </div>
                </div>
            </div>
            </div>
            <div class="agg-view-panel" id="aggViewPanel">
            <div class="agg-section" id="aggSection">
                <div class="agg-toolbar agg-header-row">
                    <span class="agg-header" id="aggSectionTitle">Fusion agglomeration size transition (2020→2050)</span>
                    <button type="button" class="btn-back" id="aggBtnBack" title="Return to country charts">← Back to country overview</button>
                </div>
                <div class="agg-placeholder" id="aggPlaceholder">Select a country from the list to view fusion agglomeration size transition.</div>
                <div class="agg-content" id="aggContent" style="display: none;">
                    <div class="agg-left">
                        <div class="agg-sankey-box">
                            <div id="aggSankeyContainer"></div>
                        </div>
                        <div class="agg-matrix-section">
                            <h3>Heatmap matrix (click cell or header to filter list)</h3>
                            <div class="agg-matrix-inner">
                                <div id="aggMatrixContainer"></div>
                            </div>
                            <p class="footnote" style="margin-top: 6px; font-size: 11px; color: #6B7A8A;">Size: Small (&lt;100k), Intermediate (100k–1M), Large (&gt;1M).</p>
                        </div>
                    </div>
                    <div id="aggDetailPanel" class="agg-list-right detail-panel">
                        <div class="list-header-row">
                            <h3 id="aggDetailTitle">Agglomerations</h3>
                            <button type="button" id="aggBtnShowAll" class="btn-all" title="Clear selection">All</button>
                        </div>
                        <div class="list-scroll">
                            <table class="agg-table" id="aggTable">
                                <thead><tr>
                                    <th data-col="name">Agglomeration</th>
                                    <th data-col="country">Country</th>
                                    <th data-col="2020">2020</th>
                                    <th data-col="2050">2050</th>
                                    <th data-col="diff">Difference</th>
                                </tr></thead>
                                <tbody id="aggList"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
            </div>
        </div>
    </div>
    <script>
        const ISO_TO_COUNTRY = { DZA: 'Algeria', AGO: 'Angola', BEN: 'Benin', BWA: 'Botswana', BFA: 'Burkina Faso', BDI: 'Burundi', CMR: 'Cameroon', CPV: 'Cape Verde', CAF: 'Central African Republic', TCD: 'Chad', COM: 'Comoros', COG: 'Congo', COD: 'DR Congo', CIV: 'Côte d\'Ivoire', DJI: 'Djibouti', EGY: 'Egypt', GNQ: 'Equatorial Guinea', ERI: 'Eritrea', SWZ: 'Eswatini', ETH: 'Ethiopia', GAB: 'Gabon', GMB: 'Gambia', GHA: 'Ghana', GIN: 'Guinea', GNB: 'Guinea-Bissau', KEN: 'Kenya', LSO: 'Lesotho', LBR: 'Liberia', LBY: 'Libya', MDG: 'Madagascar', MWI: 'Malawi', MLI: 'Mali', MRT: 'Mauritania', MUS: 'Mauritius', MAR: 'Morocco', MOZ: 'Mozambique', NAM: 'Namibia', NER: 'Niger', NGA: 'Nigeria', RWA: 'Rwanda', STP: 'São Tomé and Príncipe', SEN: 'Senegal', SYC: 'Seychelles', SLE: 'Sierra Leone', SOM: 'Somalia', ZAF: 'South Africa', SSD: 'South Sudan', SDN: 'Sudan', TZA: 'Tanzania', TGO: 'Togo', TUN: 'Tunisia', UGA: 'Uganda', ESH: 'Western Sahara', ZMB: 'Zambia', ZWE: 'Zimbabwe' };

        function getISOFromCountryField(val) {
            if (!val) return null;
            const s = String(val).trim();
            if (s.length === 3 && /^[A-Z]{3}$/i.test(s)) return s.toUpperCase();
            const entry = Object.entries(ISO_TO_COUNTRY).find(([iso, name]) => name === s);
            return entry ? entry[0] : null;
        }

        function getAllCountryIsos() {
            return Object.keys(ISO_TO_COUNTRY).sort();
        }

        function getCountryDisplayName(isoOrName) {
            if (!isoOrName) return '';
            const s = String(isoOrName).trim();
            if (s.length === 3 && /^[A-Z]{3}$/i.test(s)) return ISO_TO_COUNTRY[s.toUpperCase()] || s;
            return s;
        }

        let workbookData = null;
        let countryData = [];
        let filteredData = [];
        let charts = {};
        let currentChartData = [];  // data currently shown in charts (for click handlers after update)
        let bubbleChartMode = 'pan';  // 'pan' | 'zoom' | 'boxSelect'
        let boxSelectStart = null;    // { x, y } in pixel when drag starts
        /* Palette aligned with index.html map/chart: M=#5B8FA3, L=#D4A574, S=#6B9B8A, Total=#8B9A9F */
        const barColor = 'rgba(91, 143, 163, 0.7)';
        const barBorder = '#5B8FA3';
        const barHighlightColor = 'rgba(212, 165, 116, 0.85)';
        const barHighlightBorder = '#D4A574';
        let selectedCountries = new Set();  // country codes, multi-select
        let aggViewActive = false;  // true only after user clicks "View fusion agglomeration"
        const parseNum = (v) => {
            if (v == null || v === '') return 0;
            const s = String(v).replace(/,/g, '');
            return Number(s) || 0;
        };

        function getCountryType(country) {
            const regions = ['North Africa', 'West Africa', 'Central Africa', 'East Africa', 'Southern Africa'];
            const orgs = ['Arab Maghreb Union', 'Common Market of Eastern and Southern Africa', 'Community of Sahel-Saharan States', 'East African Community', 'Economic Community of Central African States', 'Economic Community of West African States', 'Intergovernmental Authority on Development', 'Southern African Development Community', 'West African Economic and Monetary Union'];
            if (!country) return 'other';
            if (country === 'Africa') return 'other';
            if (regions.includes(country)) return 'other';
            if (orgs.includes(country)) return 'other';
            return 'country';
        }

        function loadData() {
            document.getElementById('tableBody').innerHTML = '<tr><td colspan="7" class="loading">Loading data...</td></tr>';
            fetch('./urban_metrics_results_100k_1000k.xlsx')
                .then(r => r.blob())
                .then(blob => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const wb = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                        workbookData = {};
                        wb.SheetNames.forEach(name => {
                            const ws = wb.Sheets[name];
                            workbookData[name] = XLSX.utils.sheet_to_json(ws, { defval: '' });
                        });
                        buildCountryData();
                    };
                    reader.readAsArrayBuffer(blob);
                })
                .catch(() => {
                    document.getElementById('tableBody').innerHTML = '<tr><td colspan="7" class="empty-state">Failed to load workbook.</td></tr>';
                });
        }

        function getMetricColumns(sheet, metric) {
            const key = metric === 'fusion' ? 'fusion' : 'absorb';
            const rows = workbookData[sheet] || [];
            if (!rows.length) return { count: [], population: [], area: [] };
            const allKeys = Object.keys(rows[0]);
            const count = allKeys.filter(c => c.toLowerCase().includes(key) && (c.toLowerCase().includes('count') || c.toLowerCase().includes('agglos')));
            const population = allKeys.filter(c => c.toLowerCase().includes(key) && c.toLowerCase().includes('population'));
            const area = allKeys.filter(c => c.toLowerCase().includes(key) && c.toLowerCase().includes('area'));
            return { count, population, area };
        }

        function pickBestColumn(arr) {
            if (!arr || !arr.length) return null;
            const with2050 = arr.filter(c => String(c).includes('2050'));
            if (with2050.length) return with2050[with2050.length - 1];
            return arr[arr.length - 1];
        }

        function pickColumnForYear(arr, year) {
            if (!arr || !arr.length) return null;
            const withYear = arr.filter(c => String(c).includes(String(year)));
            if (withYear.length) return withYear[withYear.length - 1];
            return arr[arr.length - 1];
        }

        function getTotalColumns(sheet) {
            const rows = workbookData[sheet] || [];
            if (!rows.length) return { population: null, area: null };
            const allKeys = Object.keys(rows[0]);
            const noFusionAbsorb = (c) => {
                const l = c.toLowerCase();
                return !l.includes('fusion') && !l.includes('absorb');
            };
            const popCols = allKeys.filter(c => noFusionAbsorb(c) && (c.startsWith('Population_') || (c.toLowerCase().includes('population') && c.match(/\d{4}/))));
            const areaCols = allKeys.filter(c => noFusionAbsorb(c) && (c.startsWith('Area_') || (c.toLowerCase().includes('area') && c.match(/\d{4}/))));
            return {
                population: pickColumnForYear(popCols, '2020'),
                area: pickColumnForYear(areaCols, '2020')
            };
        }

        function buildCountryData() {
            const sheet = 'Fixed_Mode';
            const metric = document.getElementById('metricType').value;
            const cols = getMetricColumns(sheet, metric);
            const countCol = pickBestColumn(cols.count);
            const popCol = pickBestColumn(cols.population);
            const areaCol = pickBestColumn(cols.area);
            const totals = getTotalColumns(sheet);

            const allIsos = getAllCountryIsos();
            const byIso = {};
            allIsos.forEach(iso => {
                byIso[iso] = {
                    country: iso,
                    countryName: ISO_TO_COUNTRY[iso],
                    count: 0,
                    population: 0,
                    area: 0,
                    totalPopulation: 0,
                    totalArea: 0,
                    hasTotal: false
                };
            });

            const rows = workbookData[sheet] || [];
            rows.forEach(row => {
                const iso = getISOFromCountryField(row.Country);
                if (!iso || !byIso[iso]) return;
                const sc = (row.Size_Class || '').toString();
                const isTotal = /total/i.test(sc);
                if (isTotal) {
                    byIso[iso].count = parseNum(row[countCol]);
                    byIso[iso].population = parseNum(row[popCol]);
                    byIso[iso].area = parseNum(row[areaCol]);
                    if (totals.population) byIso[iso].totalPopulation = parseNum(row[totals.population]);
                    if (totals.area) byIso[iso].totalArea = parseNum(row[totals.area]);
                    byIso[iso].hasTotal = true;
                } else if (!byIso[iso].hasTotal) {
                    byIso[iso].count += parseNum(row[countCol]);
                    byIso[iso].population += parseNum(row[popCol]);
                    byIso[iso].area += parseNum(row[areaCol]);
                    if (totals.population) byIso[iso].totalPopulation += parseNum(row[totals.population]);
                    if (totals.area) byIso[iso].totalArea += parseNum(row[totals.area]);
                }
            });

            countryData = allIsos.map(iso => byIso[iso]);
            const n = countryData.length;
            const rankCount = [...countryData].sort((a, b) => b.count - a.count);
            const rankPop = [...countryData].sort((a, b) => b.population - a.population);
            const rankArea = [...countryData].sort((a, b) => b.area - a.area);
            const rankMap = (arr) => {
                const order = {};
                arr.forEach((r, i) => { order[r.country] = i; });
                return order;
            };
            const rc = rankMap(rankCount);
            const rp = rankMap(rankPop);
            const ra = rankMap(rankArea);
            countryData.forEach(d => {
                const r1 = n ? 1 - (rc[d.country] ?? n - 1) / n : 0;
                const r2 = n ? 1 - (rp[d.country] ?? n - 1) / n : 0;
                const r3 = n ? 1 - (ra[d.country] ?? n - 1) / n : 0;
                d.score = (r1 + r2 + r3) / 3;
                d.sharePop = d.totalPopulation > 0 ? (d.population / d.totalPopulation) * 100 : null;
                d.shareArea = d.totalArea > 0 ? (d.area / d.totalArea) * 100 : null;
            });
            const zaf = countryData.find(d => d.country === 'ZAF');
            if (zaf) {
                console.log('South Africa (ZAF) – totalPopulation/totalArea use 2020 columns:', {
                    country: zaf.country,
                    countryName: zaf.countryName,
                    count: zaf.count,
                    population: zaf.population,
                    area: zaf.area,
                    totalPopulation: zaf.totalPopulation,
                    totalArea: zaf.totalArea,
                    sharePop: zaf.sharePop != null ? zaf.sharePop.toFixed(2) + '%' : null,
                    shareArea: zaf.shareArea != null ? zaf.shareArea.toFixed(2) + '%' : null,
                    score: zaf.score.toFixed(2)
                });
            }
            const bdi = countryData.find(d => d.country === 'BDI');
            if (bdi) {
                console.log('Burundi (BDI) – totalPopulation/totalArea use 2020 columns:', {
                    country: bdi.country,
                    countryName: bdi.countryName,
                    count: bdi.count,
                    population: bdi.population,
                    area: bdi.area,
                    totalPopulation: bdi.totalPopulation,
                    totalArea: bdi.totalArea,
                    sharePop: bdi.sharePop != null ? bdi.sharePop.toFixed(2) + '%' : null,
                    shareArea: bdi.shareArea != null ? bdi.shareArea.toFixed(2) + '%' : null,
                    score: bdi.score.toFixed(2)
                });
            }
            applyFilters();
        }

        function applyFilters() {
            const q = (document.getElementById('searchCountry').value || '').trim().toLowerCase();
            const sortKey = document.getElementById('sortBy').value;
            filteredData = countryData.filter(d => {
                if (!q) return true;
                const name = (d.countryName || getCountryDisplayName(d.country) || d.country || '').toLowerCase();
                const code = (d.country || '').toLowerCase();
                return name.includes(q) || code.includes(q);
            });
            filteredData.sort((a, b) => {
                let va = a[sortKey], vb = b[sortKey];
                if (sortKey === 'score') return vb - va;
                if (sortKey === 'sharePop' || sortKey === 'shareArea') {
                    const na = va != null && Number.isFinite(va) ? va : -1;
                    const nb = vb != null && Number.isFinite(vb) ? vb : -1;
                    return nb - na;
                }
                return (vb || 0) - (va || 0);
            });
            const topN = Math.min(parseInt(document.getElementById('topN').value, 10) || 999, filteredData.length);
            const forCharts = filteredData.slice(0, topN);
            renderTable(forCharts);
            renderCharts(forCharts);
        }

        function getListColumnVisibility() {
            return {
                count: document.getElementById('colCount') && document.getElementById('colCount').checked,
                pop: document.getElementById('colPop') && document.getElementById('colPop').checked,
                area: document.getElementById('colArea') && document.getElementById('colArea').checked
            };
        }

        function renderTable(rows) {
            const thead = document.getElementById('tableHead');
            const tbody = document.getElementById('tableBody');
            const vis = getListColumnVisibility();
            const cols = [
                { key: 'country', label: 'Country', sort: null, num: false },
                ...(vis.count ? [{ key: 'count', label: 'Count', sort: 'count', num: true }] : []),
                ...(vis.area ? [{ key: 'area', label: 'Area (km²)', sort: 'area', num: true }] : []),
                ...(vis.pop ? [{ key: 'population', label: 'Pop', sort: 'population', num: true }] : []),
                { key: 'sharePop', label: 'Pop %', sort: 'sharePop', num: true, title: 'Fusion/absorb population as % of country total' },
                { key: 'shareArea', label: 'Area %', sort: 'shareArea', num: true, title: 'Fusion/absorb area as % of country total' },
                { key: 'score', label: 'Score', sort: 'score', num: true }
            ];
            thead.innerHTML = cols.map(c => `<th ${c.sort != null ? `data-sort="${c.sort}"` : ''} class="${c.num ? 'num' : ''}" ${c.title ? `title="${c.title}"` : ''}>${c.label}</th>`).join('');
            if (!rows.length) {
                tbody.innerHTML = `<tr><td colspan="${cols.length}" class="empty-state">No data</td></tr>`;
                return;
            }
            const maxScore = Math.max(...rows.map(r => r.score), 0.001);
            tbody.innerHTML = rows.map((r, i) => {
                const safe = (s) => String(s || '').replace(/"/g, '&quot;');
                const name = r.countryName || getCountryDisplayName(r.country) || r.country;
                const popPct = r.sharePop != null ? r.sharePop.toFixed(1) + '%' : '—';
                const areaPct = r.shareArea != null ? r.shareArea.toFixed(1) + '%' : '—';
                const popBar = r.sharePop != null ? Math.min(r.sharePop, 100).toFixed(1) : 0;
                const areaBar = r.shareArea != null ? Math.min(r.shareArea, 100).toFixed(1) : 0;
                const cells = [];
                cells.push(`<td>${name}</td>`);
                if (vis.count) cells.push(`<td class="num">${Math.round(r.count).toLocaleString('en-US')}</td>`);
                if (vis.area) cells.push(`<td class="num">${Math.round(r.area).toLocaleString('en-US')}</td>`);
                if (vis.pop) cells.push(`<td class="num">${Math.round(r.population).toLocaleString('en-US')}</td>`);
                cells.push(`<td class="num" title="Share of country total population"><div class="score-bar"><div class="score-bar-fill" style="width:${popBar}%"></div></div> ${popPct}</td>`);
                cells.push(`<td class="num" title="Share of country total area"><div class="score-bar"><div class="score-bar-fill" style="width:${areaBar}%"></div></div> ${areaPct}</td>`);
                cells.push(`<td class="num"><div class="score-bar"><div class="score-bar-fill" style="width:${(r.score / maxScore * 100).toFixed(0)}%"></div></div> ${r.score.toFixed(2)}</td>`);
                return `<tr data-country="${safe(r.country)}" data-index="${i}">${cells.join('')}</tr>`;
            }).join('');

            document.querySelectorAll('#dataTable th[data-sort]').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
                th.onclick = () => {
                    const key = th.dataset.sort;
                    if (!key) return;
                    const asc = th.classList.contains('sorted-desc');
                    filteredData.sort((a, b) => {
                        let va = a[key], vb = b[key];
                        if (key === 'score') return asc ? va - vb : vb - va;
                        if (key === 'sharePop' || key === 'shareArea') {
                            const na = va != null && Number.isFinite(va) ? va : -1;
                            const nb = vb != null && Number.isFinite(vb) ? vb : -1;
                            return asc ? na - nb : nb - na;
                        }
                        return asc ? (va || 0) - (vb || 0) : (vb || 0) - (va || 0);
                    });
                    document.getElementById('sortBy').value = key;
                    const topN = Math.min(parseInt(document.getElementById('topN').value, 10) || 999, filteredData.length);
                    const forCharts = filteredData.slice(0, topN);
                    renderTable(forCharts);
                    renderCharts(forCharts);
                    th.classList.toggle('sorted-asc', asc);
                    th.classList.toggle('sorted-desc', !asc);
                };
            });

            applyHighlightToTable();
            tbody.querySelectorAll('tr').forEach(tr => {
                tr.addEventListener('click', (e) => {
                    const country = tr.dataset.country;
                    if (!country) return;
                    if (selectedCountries.has(country)) selectedCountries.delete(country);
                    else selectedCountries.add(country);
                    applyHighlightToTable();
                    applyHighlightToCharts();
                    if (typeof updateAgglomerationSection === 'function') updateAgglomerationSection();
                });
            });
        }

        function applyHighlightToTable() {
            document.querySelectorAll('#tableBody tr[data-country]').forEach(tr => {
                tr.classList.toggle('highlighted', selectedCountries.has(tr.dataset.country));
            });
        }

        function applyHighlightToCharts() {
            const data = currentChartData;
            if (!data.length || !charts.rank) return;
            const bg = data.map(d => selectedCountries.has(d.country) ? barHighlightColor : barColor);
            const border = data.map(d => selectedCountries.has(d.country) ? barHighlightBorder : barBorder);
            [charts.rank, charts.count, charts.population, charts.area, charts.sharePop, charts.shareArea].forEach(ch => {
                if (ch && ch.data && ch.data.datasets && ch.data.datasets[0]) {
                    ch.data.datasets[0].backgroundColor = bg;
                    ch.data.datasets[0].borderColor = border;
                    ch.update('none');
                }
            });
            if (charts.scatter && charts.scatter.data.datasets[0]) {
                charts.scatter.data.datasets[0].backgroundColor = bg;
                charts.scatter.data.datasets[0].borderColor = border;
                charts.scatter.update('none');
            }
        }

        function barChartOnClick(ev, els) {
            const data = currentChartData;
            if (!els.length || !data || !data[els[0].index]) return;
            const country = data[els[0].index].country;
            if (selectedCountries.has(country)) selectedCountries.delete(country);
            else selectedCountries.add(country);
            applyHighlightToTable();
            applyHighlightToCharts();
            if (typeof updateAgglomerationSection === 'function') updateAgglomerationSection();
            const row = document.querySelector(`#tableBody tr[data-country="${(country || '').replace(/"/g, '&quot;')}"]`);
            if (row) row.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }

        const BUBBLE_LABEL_TOP_N = 12;
        const bubblePiePlugin = {
            id: 'bubblePiePlugin',
            afterDatasetDraw(chart, args) {
                if (chart.config.type !== 'bubble') return;
                if (args.index !== 0) return;
                const meta = chart.getDatasetMeta(0);
                if (!meta || !meta.data.length) return;
                const ctx = chart.ctx;
                const primaryBase = { r: 91, g: 143, b: 163 };
                const sliceRest = 'rgba(232, 230, 225, 0.85)';
                const dataset = chart.data.datasets[0] && chart.data.datasets[0].data;
                meta.data.forEach((el, i) => {
                    const point = (dataset && dataset[i]) || {};
                    const shareArea = Math.min(100, Math.max(0, Number(point.shareArea) || 0));
                    const sharePop = Math.min(100, Math.max(0, Number(point.sharePop) || 0));
                    const cx = el.x;
                    const cy = el.y;
                    let radiusPx = 0;
                    if (el.width != null && el.height != null) radiusPx = (el.width + el.height) / 4;
                    if (radiusPx <= 0 && point.r != null) {
                        const rVal = Number(point.r) || 15;
                        radiusPx = Math.max(6, 4 + (rVal - 5) * 1.2);
                    }
                    if (radiusPx <= 0) radiusPx = 10;
                    const alpha = 0.35 + 0.6 * (sharePop / 100);
                    const country = point.raw && point.raw.country;
                    const isHighlight = country && selectedCountries.has(country);
                    const highlightBase = { r: 212, g: 165, b: 116 };
                    const slicePrimary = isHighlight
                        ? `rgba(${highlightBase.r}, ${highlightBase.g}, ${highlightBase.b}, ${Math.min(1, alpha + 0.2)})`
                        : `rgba(${primaryBase.r}, ${primaryBase.g}, ${primaryBase.b}, ${alpha})`;
                    const startAngle = -Math.PI / 2;
                    const slice1End = startAngle + (shareArea / 100) * 2 * Math.PI;
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(cx, cy, radiusPx, startAngle, slice1End);
                    ctx.lineTo(cx, cy);
                    ctx.closePath();
                    ctx.fillStyle = slicePrimary;
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(cx, cy, radiusPx, slice1End, startAngle + 2 * Math.PI);
                    ctx.lineTo(cx, cy);
                    ctx.closePath();
                    ctx.fillStyle = sliceRest;
                    ctx.fill();
                    ctx.restore();
                });
            }
        };
        const bubbleCountryLabelsPlugin = {
            id: 'bubbleCountryLabels',
            afterDraw(chart) {
                if (chart.config.type !== 'bubble') return;
                const meta = chart._bubbleLabelData;
                if (!meta || !meta.currentChartData || !meta.topN) return;
                const data = meta.currentChartData;
                const topN = meta.topN;
                const sortKey = meta.sortKey || 'score';
                const getVal = (d) => {
                    const v = d[sortKey];
                    return v != null && Number.isFinite(v) ? v : 0;
                };
                const indices = data
                    .map((d, i) => ({ i, val: getVal(d) }))
                    .sort((a, b) => b.val - a.val)
                    .slice(0, topN)
                    .map(x => x.i);
                const elements = chart.getDatasetMeta(0).data;
                const ctx = chart.ctx;
                const paddingH = 5;
                const paddingV = 2;
                const gap = 6;
                const radius = 4;
                const font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.save();
                ctx.font = font;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                indices.forEach((idx, i) => {
                    const el = elements[idx];
                    if (!el || el.x == null) return;
                    const d = data[idx];
                    const name = d.countryName || getCountryDisplayName(d.country) || d.country || '';
                    if (!name) return;
                    const tw = ctx.measureText(name).width;
                    const boxW = tw + paddingH * 2;
                    const boxH = 10 + paddingV * 2;
                    const offsetY = (i % 3 - 1) * 5;
                    const labelX = el.x + gap;
                    const boxX = labelX - paddingH;
                    const textY = el.y + offsetY;
                    const boxY = textY - boxH / 2;
                    if (typeof ctx.roundRect === 'function') {
                        ctx.beginPath();
                        ctx.roundRect(boxX, boxY, boxW, boxH, radius);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.45)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(232, 230, 225, 0.5)';
                        ctx.lineWidth = 0.8;
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.45)';
                        ctx.strokeStyle = 'rgba(232, 230, 225, 0.5)';
                        ctx.lineWidth = 0.8;
                        ctx.beginPath();
                        const r = Math.min(radius, boxH / 2);
                        ctx.moveTo(boxX + r, boxY);
                        ctx.lineTo(boxX + boxW - r, boxY);
                        ctx.quadraticCurveTo(boxX + boxW, boxY, boxX + boxW, boxY + r);
                        ctx.lineTo(boxX + boxW, boxY + boxH - r);
                        ctx.quadraticCurveTo(boxX + boxW, boxY + boxH, boxX + boxW - r, boxY + boxH);
                        ctx.lineTo(boxX + r, boxY + boxH);
                        ctx.quadraticCurveTo(boxX, boxY + boxH, boxX, boxY + boxH - r);
                        ctx.lineTo(boxX, boxY + r);
                        ctx.quadraticCurveTo(boxX, boxY, boxX + r, boxY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }
                    ctx.fillStyle = 'rgba(44, 62, 80, 0.78)';
                    ctx.fillText(name, labelX, textY);
                });
                ctx.restore();
            }
        };
        if (typeof Chart !== 'undefined') {
            Chart.register(bubblePiePlugin, bubbleCountryLabelsPlugin);
        }
        function renderCharts(data) {
            const metric = document.getElementById('metricType').value;
            const label = metric === 'fusion' ? 'Fusion' : 'Absorb';
            const labels = data.map(d => d.countryName || getCountryDisplayName(d.country) || d.country);
            const scores = data.map(d => d.score);
            const counts = data.map(d => d.count);
            const pops = data.map(d => d.population);
            const areas = data.map(d => d.area);
            const sharePops = data.map(d => d.sharePop != null ? d.sharePop : 0);
            const shareAreas = data.map(d => d.shareArea != null ? d.shareArea : 0);

            // Fixed scale from full dataset so bar lengths stay comparable when sort/filter changes
            const scaleMaxCount = countryData.length ? Math.max(...countryData.map(d => d.count), 1) : 1;
            const scaleMaxPop = countryData.length ? Math.max(...countryData.map(d => d.population), 1) : 1;
            const scaleMaxArea = countryData.length ? Math.max(...countryData.map(d => d.area), 1) : 1;

            const sortBy = document.getElementById('sortBy').value;
            const yKey = sortBy;
            const xKey = sortBy === 'score' ? 'count' : 'score';
            const clampAxis = (val, key) => {
                if (key === 'score') return Math.min(1, Math.max(0, Number(val) || 0));
                if (key === 'sharePop' || key === 'shareArea') return Math.min(100, Math.max(0, Number(val) || 0));
                return Number(val) || 0;
            };
            const yVals = data.map(d => clampAxis(d[yKey], yKey));
            const xVals = data.map(d => clampAxis(d[xKey], xKey));
            const maxArea = Math.max(...areas, 1);
            const radii = areas.map(a => 5 + 25 * Math.sqrt(a / maxArea));
            const bubbleData = data.map((d, i) => ({
                x: xVals[i],
                y: yVals[i],
                r: radii[i],
                shareArea: d.shareArea != null ? d.shareArea : 0,
                sharePop: d.sharePop != null ? d.sharePop : 0,
                raw: d
            }));

            currentChartData = data;

            // Update existing charts so bars/bubbles animate (no full redraw)
            if (charts.rank) {
                charts.rank.data.labels = labels;
                charts.rank.data.datasets[0].data = scores;
                charts.rank.options.scales.x.max = 1;
                charts.rank.update();

                charts.count.data.labels = labels;
                charts.count.data.datasets[0].data = counts;
                charts.count.options.scales.x.max = scaleMaxCount;
                charts.count.update();

                charts.population.data.labels = labels;
                charts.population.data.datasets[0].data = pops;
                charts.population.options.scales.x.max = scaleMaxPop;
                charts.population.update();

                charts.area.data.labels = labels;
                charts.area.data.datasets[0].data = areas;
                charts.area.options.scales.x.max = scaleMaxArea;
                charts.area.update();

                if (charts.sharePop) {
                    charts.sharePop.data.labels = labels;
                    charts.sharePop.data.datasets[0].data = sharePops;
                    charts.sharePop.options.scales.x.max = 100;
                    charts.sharePop.update();
                }
                if (charts.shareArea) {
                    charts.shareArea.data.labels = labels;
                    charts.shareArea.data.datasets[0].data = shareAreas;
                    charts.shareArea.options.scales.x.max = 100;
                    charts.shareArea.update();
                }

                charts.scatter.data.datasets[0].data = bubbleData;
                const xTitle = xKey === 'score' ? 'Score' : `${label} count (agglos)`;
                const yTitle = yKey === 'score' ? 'Score' : yKey === 'count' ? `${label} count (agglos)` : yKey === 'population' ? 'Population' : yKey === 'area' ? 'Area (km²)' : yKey === 'sharePop' ? 'Pop %' : yKey === 'shareArea' ? 'Area %' : yKey;
                charts.scatter.options.scales.x.title.text = xTitle;
                charts.scatter.options.scales.y.title.text = yTitle;
                const xMax = xKey === 'score' ? 1 : scaleMaxCount;
                const yMax = yKey === 'score' ? 1 : yKey === 'sharePop' || yKey === 'shareArea' ? 100 : yKey === 'count' ? scaleMaxCount : yKey === 'population' ? scaleMaxPop : scaleMaxArea;
                charts.scatter.options.scales.x.max = xMax;
                charts.scatter.options.scales.y.max = yMax;
                charts.scatter.options.scales.x.min = 0;
                charts.scatter.options.scales.y.min = 0;
                document.getElementById('bubbleChartTitle').textContent = `${yTitle} vs ${xTitle} (pie = area%, size = area, color = pop%)`;
                charts.scatter._bubbleLabelData = { currentChartData: data, topN: BUBBLE_LABEL_TOP_N, sortKey: yKey };
                charts.scatter._bubbleAxisKeys = { xKey, yKey };
                charts.scatter.update();
                applyHighlightToCharts();
                return;
            }

            const barOpt = (title, values, fmt, xMax) => ({
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                animation: true,
                plugins: {
                    legend: { display: false },
                    tooltip: { callbacks: { label: (c) => `${title}: ${fmt(c.raw)}` } }
                },
                scales: {
                    x: { min: 0, max: xMax, beginAtZero: true },
                    y: { ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 20 } }
                },
                onClick: (ev, els) => barChartOnClick(ev, els)
            });

            charts.rank = new Chart(document.getElementById('chartRank').getContext('2d'), {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Score',
                        data: scores,
                        backgroundColor: barColor,
                        borderColor: barBorder,
                        borderWidth: 1
                    }]
                },
                options: barOpt('Score', scores, v => v.toFixed(2), 1)
            });

            charts.count = new Chart(document.getElementById('chartCount').getContext('2d'), {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Count',
                        data: counts,
                        backgroundColor: barColor,
                        borderColor: barBorder,
                        borderWidth: 1
                    }]
                },
                options: barOpt('Count', counts, v => Math.round(v).toLocaleString('en-US'), scaleMaxCount)
            });

            charts.population = new Chart(document.getElementById('chartPopulation').getContext('2d'), {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Population',
                        data: pops,
                        backgroundColor: barColor,
                        borderColor: barBorder,
                        borderWidth: 1
                    }]
                },
                options: barOpt('Population', pops, v => Math.round(v).toLocaleString('en-US'), scaleMaxPop)
            });

            charts.area = new Chart(document.getElementById('chartArea').getContext('2d'), {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Area',
                        data: areas,
                        backgroundColor: barColor,
                        borderColor: barBorder,
                        borderWidth: 1
                    }]
                },
                options: barOpt('Area (km²)', areas, v => Math.round(v).toLocaleString('en-US'), scaleMaxArea)
            });

            charts.sharePop = new Chart(document.getElementById('chartSharePop').getContext('2d'), {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Pop %',
                        data: sharePops,
                        backgroundColor: barColor,
                        borderColor: barBorder,
                        borderWidth: 1
                    }]
                },
                options: barOpt('Pop %', sharePops, v => (Number(v).toFixed(1) + '%'), 100)
            });

            charts.shareArea = new Chart(document.getElementById('chartShareArea').getContext('2d'), {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Area %',
                        data: shareAreas,
                        backgroundColor: barColor,
                        borderColor: barBorder,
                        borderWidth: 1
                    }]
                },
                options: barOpt('Area %', shareAreas, v => (Number(v).toFixed(1) + '%'), 100)
            });

            applyHighlightToCharts();

            const xTitle = xKey === 'score' ? 'Score' : `${label} count (agglos)`;
            const yTitle = yKey === 'score' ? 'Score' : yKey === 'count' ? `${label} count (agglos)` : yKey === 'population' ? 'Population' : yKey === 'area' ? 'Area (km²)' : yKey === 'sharePop' ? 'Pop %' : yKey === 'shareArea' ? 'Area %' : yKey;
            const xMax = xKey === 'score' ? 1 : scaleMaxCount;
            const yMax = yKey === 'score' ? 1 : yKey === 'sharePop' || yKey === 'shareArea' ? 100 : yKey === 'count' ? scaleMaxCount : yKey === 'population' ? scaleMaxPop : scaleMaxArea;
            document.getElementById('bubbleChartTitle').textContent = `${yTitle} vs ${xTitle} (pie = area%, size = area, color = pop%)`;

            const ctxScatter = document.getElementById('chartScatter').getContext('2d');
            const zoomPlugin = typeof Chart !== 'undefined' && Chart.registry && Chart.registry.getPlugin('zoom');
            charts.scatter = new Chart(ctxScatter, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: 'Countries',
                        data: bubbleData,
                        backgroundColor: 'transparent',
                        borderColor: 'transparent',
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: true,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: false,
                            external: function(context) {
                                const el = document.getElementById('bubbleTooltip');
                                if (!el) return;
                                const { chart, tooltip } = context;
                                if (tooltip.opacity === 0 || !tooltip.dataPoints || !tooltip.dataPoints.length) {
                                    el.classList.remove('visible');
                                    el.setAttribute('aria-hidden', 'true');
                                    return;
                                }
                                const d = tooltip.dataPoints[0].raw && tooltip.dataPoints[0].raw.raw ? tooltip.dataPoints[0].raw.raw : currentChartData[tooltip.dataPoints[0].dataIndex];
                                const countryName = d ? (d.countryName || getCountryDisplayName(d.country) || d.country) : '';
                                const lines = d ? [
                                    countryName,
                                    `${xTitle}: ${(d[xKey] != null ? (xKey === 'score' ? d[xKey].toFixed(2) : Number(d[xKey]).toLocaleString('en-US')) : '—')}`,
                                    `${yTitle}: ${(d[yKey] != null ? (yKey === 'score' ? d[yKey].toFixed(2) : yKey === 'sharePop' || yKey === 'shareArea' ? d[yKey].toFixed(1) + '%' : Number(d[yKey]).toLocaleString('en-US')) : '—')}`,
                                    `Area: ${(d.area || 0).toLocaleString('en-US')} km²`,
                                    `Area %: ${(d.shareArea != null ? d.shareArea.toFixed(1) : '—')}%`,
                                    `Pop %: ${(d.sharePop != null ? d.sharePop.toFixed(1) : '—')}%`
                                ] : [];
                                el.innerHTML = '<div class="tt-title">' + (lines[0] || '') + '</div><div class="tt-body">' + (lines.slice(1).join('\n') || '') + '</div>';
                                el.classList.add('visible');
                                el.setAttribute('aria-hidden', 'false');
                                const container = document.getElementById('bubbleChartContainer');
                                const canvasRect = chart.canvas.getBoundingClientRect();
                                const containerRect = container.getBoundingClientRect();
                                const px = canvasRect.left - containerRect.left + tooltip.caretX;
                                const py = canvasRect.top - containerRect.top + tooltip.caretY;
                                const gap = 10;
                                let left = px - el.offsetWidth / 2;
                                let top = py - el.offsetHeight - gap;
                                if (left < 4) left = 4;
                                if (left + el.offsetWidth > container.offsetWidth - 4) left = container.offsetWidth - el.offsetWidth - 4;
                                if (top < 4) top = py + gap;
                                el.style.left = left + 'px';
                                el.style.top = top + 'px';
                            }
                        },
                        zoom: zoomPlugin ? {
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                drag: { enabled: false },
                                mode: 'xy'
                            },
                            pan: {
                                enabled: true,
                                mode: 'xy'
                            },
                            limits: {
                                x: { min: 'original', max: 'original' },
                                y: { min: 'original', max: 'original' }
                            }
                        } : {}
                    },
                    scales: {
                        x: { min: 0, max: xMax, title: { display: true, text: xTitle } },
                        y: { min: 0, max: yMax, title: { display: true, text: yTitle } },
                        r: { display: false, min: 0, max: 35 }
                    },
                    onClick: (ev, els) => {
                        if (bubbleChartMode === 'boxSelect') return;
                        if (!els.length) return;
                        const i = els[0].index;
                        const d = currentChartData[i];
                        if (!d) return;
                        const country = d.country;
                        if (selectedCountries.has(country)) selectedCountries.delete(country);
                        else selectedCountries.add(country);
                        applyHighlightToTable();
                        applyHighlightToCharts();
                        if (typeof updateAgglomerationSection === 'function') updateAgglomerationSection();
                        const row = document.querySelector(`#tableBody tr[data-country="${(country || '').replace(/"/g, '&quot;')}"]`);
                        if (row) row.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    }
                }
            });
            charts.scatter._bubbleLabelData = { currentChartData: data, topN: BUBBLE_LABEL_TOP_N, sortKey: yKey };
            charts.scatter._bubbleAxisKeys = { xKey, yKey };

            const zoomBtn = document.getElementById('bubbleZoomBtn');
            const panBtn = document.getElementById('bubblePanBtn');
            const boxSelectBtn = document.getElementById('bubbleBoxSelectBtn');
            const homeBtn = document.getElementById('bubbleHomeBtn');
            const scatterCanvas = document.getElementById('chartScatter');
            const selectionRect = document.getElementById('bubbleSelectionRect');

            function setBubbleMode(mode) {
                bubbleChartMode = mode;
                zoomBtn.classList.toggle('active', mode === 'zoom');
                panBtn.classList.toggle('active', mode === 'pan');
                if (boxSelectBtn) boxSelectBtn.classList.toggle('active', mode === 'boxSelect');
                if (charts.scatter && charts.scatter.options.plugins.zoom) {
                    const z = charts.scatter.options.plugins.zoom;
                    z.zoom.drag.enabled = (mode === 'zoom');
                    z.pan.enabled = (mode === 'pan');
                    charts.scatter.update('none');
                }
            }

            if (zoomBtn) zoomBtn.addEventListener('click', () => setBubbleMode('zoom'));
            if (panBtn) panBtn.addEventListener('click', () => setBubbleMode('pan'));
            if (boxSelectBtn) boxSelectBtn.addEventListener('click', () => setBubbleMode('boxSelect'));
            if (homeBtn) homeBtn.addEventListener('click', () => {
                if (charts.scatter && typeof charts.scatter.resetZoom === 'function') {
                    charts.scatter.resetZoom();
                    zoomBtn.classList.remove('active');
                    panBtn.classList.remove('active');
                    if (boxSelectBtn) boxSelectBtn.classList.remove('active');
                    bubbleChartMode = 'pan';
                    panBtn.classList.add('active');
                }
            });

            if (scatterCanvas && selectionRect && !window.bubbleBoxSelectListenersAttached) {
                window.bubbleBoxSelectListenersAttached = true;
                scatterCanvas.addEventListener('mousedown', (e) => {
                    if (bubbleChartMode !== 'boxSelect' || !charts.scatter) return;
                    const rect = scatterCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    boxSelectStart = { x, y };
                    selectionRect.style.left = x + 'px';
                    selectionRect.style.top = y + 'px';
                    selectionRect.style.width = '0';
                    selectionRect.style.height = '0';
                    selectionRect.classList.add('visible');
                });
                scatterCanvas.addEventListener('mousemove', (e) => {
                    if (!boxSelectStart || !charts.scatter) return;
                    const rect = scatterCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const left = Math.min(boxSelectStart.x, x);
                    const top = Math.min(boxSelectStart.y, y);
                    const width = Math.abs(x - boxSelectStart.x);
                    const height = Math.abs(y - boxSelectStart.y);
                    selectionRect.style.left = left + 'px';
                    selectionRect.style.top = top + 'px';
                    selectionRect.style.width = width + 'px';
                    selectionRect.style.height = height + 'px';
                });
                scatterCanvas.addEventListener('mouseup', (e) => {
                    if (!boxSelectStart || !charts.scatter) return;
                    const rect = scatterCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const left = Math.min(boxSelectStart.x, x);
                    const top = Math.min(boxSelectStart.y, y);
                    const width = Math.abs(x - boxSelectStart.x);
                    const height = Math.abs(y - boxSelectStart.y);
                    selectionRect.classList.remove('visible');
                    boxSelectStart = null;

                    if (width < 4 && height < 4) return;
                    const xScale = charts.scatter.scales.x;
                    const yScale = charts.scatter.scales.y;
                    if (!xScale || !yScale) return;
                    const xMin = xScale.getValueForPixel(left);
                    const xMax = xScale.getValueForPixel(left + width);
                    const yMin = yScale.getValueForPixel(top + height);
                    const yMax = yScale.getValueForPixel(top);
                    const dataMinX = Math.min(xMin, xMax);
                    const dataMaxX = Math.max(xMin, xMax);
                    const dataMinY = Math.min(yMin, yMax);
                    const dataMaxY = Math.max(yMin, yMax);

                    selectedCountries.clear();
                    const axisKeys = charts.scatter._bubbleAxisKeys || { xKey: 'count', yKey: 'population' };
                    currentChartData.forEach((d, i) => {
                        const bx = (d[axisKeys.xKey] != null) ? d[axisKeys.xKey] : 0;
                        const by = (d[axisKeys.yKey] != null) ? d[axisKeys.yKey] : 0;
                        if (bx >= dataMinX && bx <= dataMaxX && by >= dataMinY && by <= dataMaxY) {
                            selectedCountries.add(d.country);
                        }
                    });
                    applyHighlightToTable();
                    applyHighlightToCharts();
                    if (typeof updateAgglomerationSection === 'function') updateAgglomerationSection();
                });
                scatterCanvas.addEventListener('mouseleave', () => {
                    if (boxSelectStart) {
                        selectionRect.classList.remove('visible');
                        boxSelectStart = null;
                    }
                });
            }
        }

        document.getElementById('metricType').addEventListener('change', () => {
            buildCountryData();
            if (typeof updateAgglomerationSection === 'function') updateAgglomerationSection();
        });
        document.getElementById('searchCountry').addEventListener('input', () => { applyFilters(); });
        document.getElementById('sortBy').addEventListener('change', () => { applyFilters(); });
        document.getElementById('topN').addEventListener('change', () => { applyFilters(); });
        ['colCount', 'colPop', 'colArea'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.addEventListener('change', () => { applyFilters(); });
        });
        document.getElementById('selectAll').addEventListener('click', () => {
            document.querySelectorAll('#tableBody tr[data-country]').forEach(tr => {
                const country = tr.dataset.country;
                if (country) selectedCountries.add(country);
            });
            applyHighlightToTable();
            applyHighlightToCharts();
            if (typeof updateAgglomerationSection === 'function') updateAgglomerationSection();
        });
        document.getElementById('clearSelection').addEventListener('click', () => {
            selectedCountries.clear();
            applyHighlightToTable();
            applyHighlightToCharts();
            if (typeof updateAgglomerationSection === 'function') updateAgglomerationSection();
        });

        document.querySelectorAll('.collapse-header').forEach(h => {
            h.addEventListener('click', () => {
                const section = h.closest('.collapse-section');
                if (!section) return;
                const isCollapsed = section.classList.toggle('collapsed');
                h.setAttribute('aria-expanded', !isCollapsed);
            });
        });

        (function() {
            const SIZE_ORDER_AGG = ['Small', 'Intermediate', 'Large'];
            const SIZE_CLASS_AGG = { Small: 'size-small', Intermediate: 'size-intermediate', Large: 'size-large' };
            const SIZE_COLOR_AGG = { Small: '#6B9B8A', Intermediate: '#5B8FA3', Large: '#D4A574' };
            let aggRawData = null;
            let aggCurrentAggLists = null;
            let aggCurrentAggsFull = [];
            let aggCurrentListRows = [];
            let aggListSortBy = null;
            let aggListSortDir = 1;
            const aggSelectedFlows = new Set();
            let aggSankeyChart = null;
            let aggBound = false;

            function buildAggMatrix(countryCodeOrCodes) {
                if (!aggRawData) return { matrix: null, total: 0, aggLists: null, aggs: [] };
                const aggs = Array.isArray(countryCodeOrCodes)
                    ? countryCodeOrCodes.flatMap(cc => (aggRawData[cc] && aggRawData[cc].agglomerations) || [])
                    : (countryCodeOrCodes ? (aggRawData[countryCodeOrCodes] && aggRawData[countryCodeOrCodes].agglomerations) || [] : Object.values(aggRawData).flatMap(c => c.agglomerations || []));
                const matrix = {};
                const aggLists = {};
                SIZE_ORDER_AGG.forEach(s20 => { matrix[s20] = {}; aggLists[s20] = {}; SIZE_ORDER_AGG.forEach(s50 => { matrix[s20][s50] = 0; aggLists[s20][s50] = []; }); });
                aggs.forEach(agg => {
                    const c20 = (agg.classification_by_year && agg.classification_by_year['2020']) || 'Small';
                    const c50 = (agg.classification_by_year && agg.classification_by_year['2050']) || 'Small';
                    const s20 = SIZE_ORDER_AGG.includes(c20) ? c20 : 'Small';
                    const s50 = SIZE_ORDER_AGG.includes(c50) ? c50 : 'Small';
                    matrix[s20][s50]++; aggLists[s20][s50].push(agg);
                });
                return { matrix, total: aggs.length, aggLists, aggs };
            }
            function aggToRow(agg) {
                const name = (agg.Agglomeration_Name || '').replace(/</g, '&lt;');
                const country = ISO_TO_COUNTRY[agg.ISO3] || agg.ISO3 || '';
                const p20 = (agg.population_by_year && agg.population_by_year['2020']) != null ? agg.population_by_year['2020'] : null;
                const p50 = (agg.population_by_year && agg.population_by_year['2050']) != null ? agg.population_by_year['2050'] : null;
                const pop20Str = p20 != null ? Math.round(p20).toLocaleString('en-US') : '—';
                const pop50Str = p50 != null ? Math.round(p50).toLocaleString('en-US') : '—';
                const diff = (p20 != null && p50 != null) ? (p50 - p20) : null;
                const diffStr = diff != null ? (diff >= 0 ? '+' : '') + Math.round(diff).toLocaleString('en-US') : '—';
                return { name, country, pop20Str, pop50Str, diffStr, _pop20: p20 != null ? p20 : -1, _pop50: p50 != null ? p50 : -1, _diff: diff != null ? diff : -Infinity };
            }
            function aggFlowKey(s20, s50) { return s20 + '-' + s50; }
            function sortAggListRows(rows) {
                if (!rows.length || !aggListSortBy) return rows;
                const key = aggListSortBy, dir = aggListSortDir;
                return rows.slice().sort((a, b) => {
                    let va, vb;
                    if (key === 'name') { va = (a.name || '').toLowerCase(); vb = (b.name || '').toLowerCase(); return dir * (va < vb ? -1 : va > vb ? 1 : 0); }
                    if (key === 'country') { va = (a.country || '').toLowerCase(); vb = (b.country || '').toLowerCase(); return dir * (va < vb ? -1 : va > vb ? 1 : 0); }
                    if (key === '2020') { va = a._pop20; vb = b._pop20; } else if (key === '2050') { va = a._pop50; vb = b._pop50; } else if (key === 'diff') { va = a._diff; vb = b._diff; } else return 0;
                    return dir * (va - vb);
                });
            }
            function updateAggListFromSelection() {
                const titleEl = document.getElementById('aggDetailTitle');
                let list = [];
                if (aggSelectedFlows.size === 0) { list = aggCurrentAggsFull; titleEl.textContent = 'All agglomerations (' + list.length + ')'; }
                else {
                    aggSelectedFlows.forEach(key => { const [s20, s50] = key.split('-'); if (aggCurrentAggLists && aggCurrentAggLists[s20] && aggCurrentAggLists[s20][s50]) list.push(...aggCurrentAggLists[s20][s50]); });
                    const labels = Array.from(aggSelectedFlows).map(k => k.replace('-', ' → '));
                    titleEl.textContent = (labels.length === 1 ? labels[0] : labels.length + ' flows') + ' (' + list.length + ')';
                }
                aggCurrentListRows = list.map(aggToRow);
                const tbody = document.getElementById('aggList');
                tbody.innerHTML = sortAggListRows(aggCurrentListRows).map(r => '<tr><td>' + r.name + '</td><td>' + r.country + '</td><td class="num">' + r.pop20Str + '</td><td class="num">' + r.pop50Str + '</td><td class="num">' + r.diffStr + '</td></tr>').join('');
                document.querySelectorAll('#aggTable th[data-col]').forEach(th => { th.classList.remove('sorted-asc', 'sorted-desc'); if (th.dataset.col === aggListSortBy) th.classList.add(aggListSortDir === 1 ? 'sorted-asc' : 'sorted-desc'); });
            }
            function updateAggMatrixHighlight() {
                const cont = document.getElementById('aggMatrixContainer');
                if (!cont) return;
                cont.querySelectorAll('.cell-heat[data-s20][data-s50]').forEach(td => { td.classList.toggle('selected', aggSelectedFlows.has(aggFlowKey(td.dataset.s20, td.dataset.s50))); });
                cont.querySelectorAll('th.col-header-click[data-node-id]').forEach(th => {
                    const nodeKeys = getAggFlowsForNode(th.dataset.nodeId);
                    th.classList.toggle('header-selected', nodeKeys.size > 0 && nodeKeys.size === aggSelectedFlows.size && [...nodeKeys].every(k => aggSelectedFlows.has(k)));
                });
                cont.querySelectorAll('td.row-header-click[data-node-id]').forEach(td => {
                    const nodeKeys = getAggFlowsForNode(td.dataset.nodeId);
                    td.classList.toggle('header-selected', nodeKeys.size > 0 && nodeKeys.size === aggSelectedFlows.size && [...nodeKeys].every(k => aggSelectedFlows.has(k)));
                });
            }
            function updateAggSankeyHighlight() {
                if (!aggSankeyChart || !aggSankeyChart.series || !aggSankeyChart.series[0]) return;
                aggSankeyChart.series[0].points.forEach(p => {
                    const k = aggFlowKey((p.from || '').replace('2020-', ''), (p.to || '').replace('2050-', ''));
                    const op = aggSelectedFlows.has(k) ? 1 : 0.6;
                    if (p.graphic) p.graphic.attr({ opacity: op }); else p.update({ opacity: op }, false);
                });
                aggSankeyChart.redraw();
            }
            function getAggFlowsForNode(nodeId) {
                const keys = new Set();
                if (!nodeId) return keys;
                if (nodeId.startsWith('2020-')) { const s20 = nodeId.replace('2020-', ''); SIZE_ORDER_AGG.forEach(s50 => keys.add(aggFlowKey(s20, s50))); }
                else if (nodeId.startsWith('2050-')) { const s50 = nodeId.replace('2050-', ''); SIZE_ORDER_AGG.forEach(s20 => keys.add(aggFlowKey(s20, s50))); }
                return keys;
            }
            function selectAggNodeFlows(nodeId) {
                const nodeKeys = getAggFlowsForNode(nodeId);
                if (!nodeKeys.size) return;
                const same = nodeKeys.size === aggSelectedFlows.size && [...nodeKeys].every(k => aggSelectedFlows.has(k));
                if (same) aggSelectedFlows.clear(); else { aggSelectedFlows.clear(); nodeKeys.forEach(k => aggSelectedFlows.add(k)); }
                updateAggListFromSelection(); updateAggMatrixHighlight(); updateAggSankeyHighlight();
            }
            function toggleAggFlow(s20, s50) {
                const key = aggFlowKey(s20, s50);
                if (aggSelectedFlows.has(key)) aggSelectedFlows.delete(key); else aggSelectedFlows.add(key);
                updateAggListFromSelection(); updateAggMatrixHighlight(); updateAggSankeyHighlight();
            }
            function clearAggSelection() {
                aggSelectedFlows.clear();
                updateAggListFromSelection(); updateAggMatrixHighlight(); updateAggSankeyHighlight();
            }
            function onAggListHeaderClick(col) {
                if (aggListSortBy === col) aggListSortDir = -aggListSortDir; else { aggListSortBy = col; aggListSortDir = 1; }
                document.querySelectorAll('#aggTable th[data-col]').forEach(th => { th.classList.remove('sorted-asc', 'sorted-desc'); if (th.dataset.col === aggListSortBy) th.classList.add(aggListSortDir === 1 ? 'sorted-asc' : 'sorted-desc'); });
                const tbody = document.getElementById('aggList');
                tbody.innerHTML = sortAggListRows(aggCurrentListRows).map(r => '<tr><td>' + r.name + '</td><td>' + r.country + '</td><td class="num">' + r.pop20Str + '</td><td class="num">' + r.pop50Str + '</td><td class="num">' + r.diffStr + '</td></tr>').join('');
            }
            function renderAggMatrix(countryCodes) {
                const container = document.getElementById('aggMatrixContainer');
                const codes = Array.isArray(countryCodes) ? countryCodes : [countryCodes];
                const result = buildAggMatrix(codes);
                const { matrix, total, aggLists, aggs } = result;
                aggCurrentAggLists = aggLists;
                aggCurrentAggsFull = aggs || [];
                if (!matrix || total === 0) {
                    container.innerHTML = '<div class="empty-state">No agglomerations for selected countries.</div>';
                    aggSelectedFlows.clear();
                    updateAggListFromSelection();
                    return;
                }
                const rowTotals = {};
                SIZE_ORDER_AGG.forEach(s20 => { rowTotals[s20] = SIZE_ORDER_AGG.reduce((sum, s50) => sum + matrix[s20][s50], 0); });
                const colTotals = {};
                SIZE_ORDER_AGG.forEach(s50 => { colTotals[s50] = SIZE_ORDER_AGG.reduce((sum, s20) => sum + matrix[s20][s50], 0); });
                let maxCell = 0;
                SIZE_ORDER_AGG.forEach(s20 => { SIZE_ORDER_AGG.forEach(s50 => { maxCell = Math.max(maxCell, matrix[s20][s50]); }); });
                const heatScale = maxCell > 0 ? v => 'rgba(91, 143, 163, ' + (0.15 + 0.7 * (v / maxCell)) + ')' : () => '#fff';
                let html = '<table class="transition-table"><thead><tr><th class="row-header">2020 ↓ / 2050 →</th>';
                SIZE_ORDER_AGG.forEach(s50 => { html += '<th class="col-header-click" data-node-id="2050-' + s50 + '" title="Click to filter by ' + s50 + ' (2050)">' + s50 + '</th>'; });
                html += '<th>Total</th></tr></thead><tbody>';
                SIZE_ORDER_AGG.forEach(s20 => {
                    const rTotal = rowTotals[s20];
                    html += '<tr class="' + (SIZE_CLASS_AGG[s20] || '') + '"><td class="row-header row-header-click" data-node-id="2020-' + s20 + '" title="Click to filter by ' + s20 + ' (2020)">' + s20 + '</td>';
                    SIZE_ORDER_AGG.forEach(s50 => {
                        const n = matrix[s20][s50];
                        const pct = rTotal > 0 ? (n / rTotal * 100).toFixed(1) : '0';
                        const bg = heatScale(n);
                        const sel = aggSelectedFlows.has(aggFlowKey(s20, s50)) ? ' selected' : '';
                        html += '<td class="num cell-heat' + sel + '" style="background:' + bg + '" data-s20="' + s20 + '" data-s50="' + s50 + '" title="Click to toggle: ' + s20 + ' → ' + s50 + ' (' + n + ')">' + n + ' <span style="color:#6B7A8A">(' + pct + '%)</span></td>';
                    });
                    html += '<td class="num">' + rTotal + '</td></tr>';
                });
                html += '<tr class="row-total"><td class="row-header">Total</td>';
                SIZE_ORDER_AGG.forEach(s50 => { html += '<td class="num">' + colTotals[s50] + '</td>'; });
                html += '<td class="num">' + total + '</td></tr></tbody></table>';
                container.innerHTML = html;
                container.querySelectorAll('.cell-heat[data-s20][data-s50]').forEach(td => { td.addEventListener('click', () => toggleAggFlow(td.dataset.s20, td.dataset.s50)); });
                container.querySelectorAll('th.col-header-click[data-node-id]').forEach(th => { th.addEventListener('click', () => selectAggNodeFlows(th.dataset.nodeId)); });
                container.querySelectorAll('td.row-header-click[data-node-id]').forEach(td => { td.addEventListener('click', () => selectAggNodeFlows(td.dataset.nodeId)); });
                updateAggMatrixHighlight();
            }
            function bindAggSankeyNodeClicks(chart) {
                const series = chart.series && chart.series[0];
                if (!series) return;
                const nodeList = series.nodeList || (series.nodes && series.nodes.length ? series.nodes : []);
                nodeList.forEach(function(node) {
                    const nodeId = (node.id != null ? node.id : (node.options && node.options.id)) || '';
                    if (!nodeId.startsWith('2020-') && !nodeId.startsWith('2050-')) return;
                    const graphic = node.graphic || (node.node && node.node.graphic);
                    const el = graphic && graphic.element;
                    if (el) { el.style.cursor = 'pointer'; el.addEventListener('click', function() { selectAggNodeFlows(nodeId); }); }
                });
            }
            function renderAggSankey(countryCodes) {
                const container = document.getElementById('aggSankeyContainer');
                const codes = Array.isArray(countryCodes) ? countryCodes : [countryCodes];
                const result = buildAggMatrix(codes);
                const { matrix, total, aggLists } = result;
                aggCurrentAggLists = aggLists;
                if (!matrix || total === 0) {
                    container.innerHTML = '<div class="empty-state">No data for selected countries.</div>';
                    if (aggSankeyChart) { aggSankeyChart.destroy(); aggSankeyChart = null; }
                    return;
                }
                const sankeyData = [];
                SIZE_ORDER_AGG.forEach(s20 => { SIZE_ORDER_AGG.forEach(s50 => { const v = matrix[s20][s50]; if (v > 0) sankeyData.push(['2020-' + s20, '2050-' + s50, v]); }); });
                if (aggSankeyChart) aggSankeyChart.destroy();
                const chartHeight = Math.max(200, container.clientHeight || 260);
                aggSankeyChart = Highcharts.chart(container, {
                    chart: { type: 'sankey', height: chartHeight, backgroundColor: 'transparent', events: { load: function() { const ch = this; setTimeout(function() { bindAggSankeyNodeClicks(ch); }, 0); } } },
                    title: { text: null },
                    tooltip: { pointFormat: '{point.from} → {point.to}: <b>{point.weight}</b> agglomerations<br/><span style="font-size:10px">Click to filter list</span>', useHTML: true, nodeFormatter: function() { return '<b>' + (this.name || this.id) + '</b><br/><span style="font-size:10px">Click to filter by this node</span>'; } },
                    plotOptions: { sankey: {
                        dataLabels: { enabled: true, format: '{point.fromNode.name} → {point.toNode.name}', nodeFormat: '{point.name}' },
                        point: { events: { click: function() { const s20 = (this.from || '').replace('2020-', ''); const s50 = (this.to || '').replace('2050-', ''); if (s20 && s50) toggleAggFlow(s20, s50); } }, cursor: 'pointer' },
                        nodeWidth: 20, nodePadding: 10
                    } },
                    series: [{ type: 'sankey', name: 'Size transition', keys: ['from', 'to', 'weight'], data: sankeyData,
                        nodes: [
                            { id: '2020-Small', name: 'S (2020)', color: SIZE_COLOR_AGG.Small }, { id: '2020-Intermediate', name: 'M (2020)', color: SIZE_COLOR_AGG.Intermediate }, { id: '2020-Large', name: 'L (2020)', color: SIZE_COLOR_AGG.Large },
                            { id: '2050-Small', name: 'S (2050)', color: SIZE_COLOR_AGG.Small }, { id: '2050-Intermediate', name: 'M (2050)', color: SIZE_COLOR_AGG.Intermediate }, { id: '2050-Large', name: 'L (2050)', color: SIZE_COLOR_AGG.Large }
                        ], colorByPoint: false, linkOpacity: 0.6
                    }]
                });
            }
            function bindAggListSort() {
                document.querySelectorAll('#aggTable th[data-col]').forEach(th => { th.addEventListener('click', () => onAggListHeaderClick(th.dataset.col)); });
            }
            window.updateAgglomerationSection = function() {
                const countryChartsPanel = document.getElementById('countryChartsPanel');
                const aggViewPanel = document.getElementById('aggViewPanel');
                const aggEntryBar = document.getElementById('aggEntryBar');
                const aggEntryCountryName = document.getElementById('aggEntryCountryName');
                const placeholder = document.getElementById('aggPlaceholder');
                const content = document.getElementById('aggContent');
                const titleEl = document.getElementById('aggSectionTitle');
                if (!placeholder || !content) return;
                const metricEl = document.getElementById('metricType');
                const metric = (metricEl && metricEl.value) || 'fusion';
                const isFusion = metric === 'fusion';
                const hasSelection = selectedCountries.size >= 1;
                const inAggView = hasSelection && aggViewActive && isFusion;
                if (countryChartsPanel) countryChartsPanel.classList.toggle('hidden', inAggView);
                if (aggViewPanel) aggViewPanel.classList.toggle('visible', inAggView);
                if (aggEntryBar && aggEntryCountryName) {
                    if (hasSelection && !aggViewActive && isFusion) {
                        aggEntryBar.style.display = 'flex';
                        aggEntryCountryName.textContent = selectedCountries.size === 1
                            ? (getCountryDisplayName(Array.from(selectedCountries)[0]) || Array.from(selectedCountries)[0])
                            : selectedCountries.size + ' countries';
                    } else {
                        aggEntryBar.style.display = 'none';
                    }
                }
                var viewAggBtn = document.getElementById('btnViewAgglomeration');
                if (viewAggBtn && !viewAggBtn._aggBound) {
                    viewAggBtn._aggBound = true;
                    viewAggBtn.addEventListener('click', function() {
                        aggViewActive = true;
                        updateAgglomerationSection();
                    });
                }
                if (selectedCountries.size === 0) {
                    aggViewActive = false;
                    placeholder.style.display = 'block';
                    content.style.display = 'none';
                    if (titleEl) titleEl.textContent = 'Agglomeration size transition (2020→2050)';
                    return;
                }
                if (!inAggView) return;
                const countryCodes = Array.from(selectedCountries);
                if (!aggRawData) {
                    placeholder.textContent = 'Loading agglomeration data…';
                    placeholder.style.display = 'block';
                    content.style.display = 'none';
                    if (titleEl) titleEl.textContent = countryCodes.length === 1
                        ? 'Agglomeration size transition (2020→2050) – ' + (getCountryDisplayName(countryCodes[0]) || countryCodes[0])
                        : 'Agglomeration size transition (2020→2050) – ' + countryCodes.length + ' countries';
                    return;
                }
                placeholder.style.display = 'none';
                content.style.display = 'flex';
                if (titleEl) titleEl.textContent = countryCodes.length === 1
                    ? 'Agglomeration size transition (2020→2050) – ' + (getCountryDisplayName(countryCodes[0]) || countryCodes[0])
                    : 'Agglomeration size transition (2020→2050) – ' + countryCodes.length + ' countries';
                renderAggMatrix(countryCodes);
                renderAggSankey(countryCodes);
                updateAggListFromSelection();
                updateAggMatrixHighlight();
                updateAggSankeyHighlight();
                if (!aggBound) {
                    aggBound = true;
                    bindAggListSort();
                    const btn = document.getElementById('aggBtnShowAll');
                    if (btn) btn.addEventListener('click', clearAggSelection);
                    const backBtn = document.getElementById('aggBtnBack');
                    if (backBtn) backBtn.addEventListener('click', function() {
                        aggViewActive = false;
                        updateAgglomerationSection();
                    });
                }
            };
            fetch('./merged_agglomerations_by_country.json')
                .then(r => r.json())
                .then(data => { aggRawData = data; if (selectedCountries.size > 0) updateAgglomerationSection(); })
                .catch(() => {});
        })();

        loadData();
    </script>
</body>
</html>
